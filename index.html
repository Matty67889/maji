<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>INFO 3300 Project 2</title>

  <!-- Import D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Import Topojson -->
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <style>
    .state {
      /* fill: lightgrey; */
    }

    .outline {
      fill: none;
      stroke: black;
      stroke-width: 1px;
    }

    .graticule {
      fill: none;
      stroke: grey;
      stroke-width: 1px;
    }
  </style>
</head>

<body>
  <!-- HTML Structure -->
  <h1>Project 2</h1>
  <h3>Map</h3>
  <svg id="disaster-svg" height="600" width="900" style="background: #445; margin-top:50px"></svg>
  <h3>Bar Chart</h3>
  <svg id="bar-chart" height="600" width="1100"></svg>

  <!-- Scripts -->
  <script>
    /*** Map visualization ***/

    const svg = d3.select("#disaster-svg");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 50, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    //aysnc func to load data and build map
    const requestData = async function () {
      //draw map
      // source: professor Rz
      const us = await d3.json("data/states-10m.json");
      console.log("us map data:\n", us);

      let states = topojson.feature(us, us.objects.states);
      let statesMesh = topojson.mesh(us, us.objects.states);
      let projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      let path = d3.geoPath().projection(projection);

      let graticule = d3.geoGraticule10();
      console.log("graticule:\n", graticule);
      map.append("path").attr("class", "graticule").attr("d", path(graticule));

      // Draw states
      let statePaths = map.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path)

      map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      const fema = await d3.csv("data/FEMA_Aid_Distribution_Data_clean.csv");
      console.log("original fema data:\n", fema);

      const disasterData = await d3.csv("data/us_disaster_declarations_clean.csv", d3.autoType);
      console.log("original disaster data:\n", disasterData);

      /*** Data cleaning ***/

      let stateAbbrevs = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT",
        "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
        "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO",
        "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND",
        "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX",
        "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
      let stateToAbbrevDict = {
        "Alabama": "AL",
        "Alaska": "AK",
        "Arizona": "AZ",
        "Arkansas": "AR",
        "California": "CA",
        "Colorado": "CO",
        "Connecticut": "CT",
        "Delaware": "DE",
        "Florida": "FL",
        "Georgia": "GA",
        "Hawaii": "HI",
        "Idaho": "ID",
        "Illinois": "IL",
        "Indiana": "IN",
        "Iowa": "IA",
        "Kansas": "KS",
        "Kentucky": "KY",
        "Louisiana": "LA",
        "Maine": "ME",
        "Maryland": "MD",
        "Massachusetts": "MA",
        "Michigan": "MI",
        "Minnesota": "MN",
        "Mississippi": "MS",
        "Missouri": "MO",
        "Montana": "MT",
        "Nebraska": "NE",
        "Nevada": "NV",
        "New Hampshire": "NH",
        "New Jersey": "NJ",
        "New Mexico": "NM",
        "New York": "NY",
        "North Carolina": "NC",
        "North Dakota": "ND",
        "Ohio": "OH",
        "Oklahoma": "OK",
        "Oregon": "OR",
        "Pennsylvania": "PA",
        "Rhode Island": "RI",
        "South Carolina": "SC",
        "South Dakota": "SD",
        "Tennessee": "TN",
        "Texas": "TX",
        "Utah": "UT",
        "Vermont": "VT",
        "Virginia": "VA",
        "Washington": "WA",
        "West Virginia": "WV",
        "Wisconsin": "WI",
        "Wyoming": "WY",
      }
      // filter out data that is not states
      let filteredFema = fema.filter(d => stateAbbrevs.includes(d['State']));
      console.log("filtered fema data:\n", filteredFema);
      filteredFema.forEach(d => {
        // cast money values to ints (they have dollar signs in front of them)
        d['Announced/Allocated'] = Number(d['Announced/Allocated'].replace(/\$/g, ''));
      });

      /*** Data aggregation ***/

      // create list of objects that contain info on each state
      let stateObjs = []

      for (const [key, value] of Object.entries(stateToAbbrevDict)) {
        stateObjs.push({
          'state': key,
          'stateAbbrev': value,
          'amntAllocated': 0,
          'numDisasters': 0,
          'uniqueDisasters': []
        });
      }

      filteredFema.forEach(d => {
        let currState = d['State'];
        let amntAllocated = d['Announced/Allocated'];

        stateObjs.forEach(obj => {
          if (obj['stateAbbrev'] === currState) {
            obj['amntAllocated'] += amntAllocated;
            obj['numDisasters'] += 1;
          }
        });
      });

      disasterData.forEach(d => {
        let currState = d['state'];
        let disasterName = d['incident_type'];

        stateObjs.forEach(obj => {
          if (obj['stateAbbrev'] === currState) {
            if (!obj['uniqueDisasters'].includes(disasterName)) {
              obj['uniqueDisasters'].push(disasterName);
            }
          }
        });
      });

      // console.log(stateObjs);

      // create color scales
      let stateColorScale = d3.scaleOrdinal()
        .domain(d3.extent(stateObjs, d => d['numDisasters']))
        .range(d3.schemeObservable10);

      map.selectAll(".state").filter(d => d['properties']['name'] in stateToAbbrevDict)
        .style("fill", d => stateColorScale(stateToAbbrevDict[d['properties']['name']]));

      /*** Tooltips ***/

      // source prof Rz 10.09 tooltip stub
      let tooltipWidth = 400;
      let tooltipHeight = 80;

      let momesh = map.append("path")
        .attr("class", "mouseover outline")
        .style("stroke", "white")
        .style("stroke-width", 3)
        .attr("d", "");

      let tooltip = map.append("g")
        .attr("class", "tooltip")
        .attr("visibility", "hidden");
      tooltip.append("rect")
        .attr("fill", "black")
        .attr("opacity", 0.9)
        .attr("x", -tooltipWidth / 2.0)
        .attr("y", 0)
        .attr("width", tooltipWidth)
        .attr("height", tooltipHeight)
      let txt = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 12)
        .attr('stroke', 'bold');
      let txt2 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 32);
      let txt3 = tooltip.append("text")
        .attr("fill", "white")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "hanging")
        .attr("x", 0)
        .attr("y", 52);

      //hover over function displaying state name,
      map.selectAll(".state").on('mouseover', function (event, d) {
        // Make tooltip visible
        tooltip.style("visibility", "visible")

        let state = d3.select(this);
        // console.log(state.datum());

        let bounds = path.bounds(state.datum());   // Get the pixel boundaries of the state

        // center the tooltip beneath each state
        let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
        let yPos = bounds[1][1] - 15;
        tooltip.attr("transform", `translate(${xPos},${yPos})`);

        let stateProperties = state.datum()['properties'];
        let stateName = stateProperties['name'];
        stateObjs.forEach(element => {
          if (element['state'] === stateName) {
            txt.text(element['state']);
            txt2.text(`Number of Total Disasters: ${element['numDisasters']}`);
            txt3.text(`Total $ Allocated for Assistance: $${Math.round(element['amntAllocated'])}`);
          }
        });

        var mo = topojson.mesh(us, us.objects.states, function (a, b) { return a['properties']['name'] === stateName || b['properties']['name'] === stateName; });
        momesh.datum(mo).attr("d", path);
      });

      map.on('mouseout', function (event, d) {
        // remove tooltip when you leave a state
        tooltip.style("visibility", "hidden");
        let state = d3.select(this);
        momesh.attr("d", "");
      });

      /*** Bar chart visualization ***/

      // create svg & set its dimensions
      const barChart = d3.select("svg#bar-chart");

      const svgWidth = barChart.attr("width");
      const svgHeight = barChart.attr("height");

      const bCMargins = { top: 20, right: 20, bottom: 50, left: 80 };
      // create bar chart's area & set its dimensions
      const barChartWidth = svgWidth - bCMargins.left - bCMargins.right;
      const barChartHeight = svgHeight - bCMargins.top - bCMargins.bottom;

      const barChartArea = barChart.append("g")
        .attr("transform", `translate(${bCMargins.left}, ${bCMargins.bottom})`);

      // // x-axis scale for bar chart
      // const stateScale = d3.scaleLinear()
      //           .domain([0,50])
      //           .range([barChartWidth-margins.left, margins.top]);

      //create array for x-axis scale, which is categorical (states instead of numbers)
      // let stateAbbrevs = []


      // stateObjs.forEach(d => {
      //   states.push(d['stateAbbrev'])
      // });

      // console.log(states)

      // x-axis scale for bar chart
      const stateScale = d3.scalePoint() //source: https://d3js.org/d3-scale/point
        .domain(stateAbbrevs)
        .range([bCMargins.top, barChartWidth - bCMargins.left]);

      // create domain for y-axis scale
      let funding = []

      stateObjs.forEach(d => {
        funding.push(d['amntAllocated'])
      });

      //two-item array containing min and max values of funding
      let fundingExtent = d3.extent(funding);

      // y-axis scale for bar chart
      const fundingScale = d3.scaleLinear()
        .domain([0, fundingExtent[1]])
        .range([barChartHeight, 10]);

      //x axis
      const xAxis = d3.axisBottom(stateScale); //create xAxis

      barChart.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${bCMargins.left}, ${bCMargins.bottom + barChartHeight})`) //move axis to correct position
        .call(xAxis);

      //y axis
      const yAxis = d3.axisLeft(fundingScale); //create yAxis

      barChart.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${bCMargins.left}, ${bCMargins.bottom})`) //move axis to correct position
        .call(yAxis);

      // Add x-axis label (States)
      barChart.append("text")
        .attr("class", "x axis-label")
        .attr("x", barChartWidth / 2)  // Center the label horizontally based on the width of the chart
        .attr("y", barChartHeight + 80) // Position below the x-axis (adjust as needed)
        .attr("text-anchor", "middle") // Align the text in the center
        .text("States");

      // Add y-axis label (Funding)
      barChart.append("text")
        .attr("class", "y axis-label")
        .attr("transform", "rotate(-90)") // Rotate the label 90 degrees for vertical alignment
        .attr("x", -barChartHeight / 2)  // Position to the left of the y-axis (center it vertically)
        .attr("y", -60) // Adjust position up from the y-axis (adjust as needed)
        .attr("text-anchor", "middle") // Center the text horizontally
        .text("Funding ($)");

      let stateNumericalDict = {
        "AL": 1, "AK": 2, "AZ": 3, "AR": 4, "CA": 5, "CO": 6, "CT": 7,
        "DE": 8, "FL": 9, "GA": 10, "HI": 11, "ID": 12, "IL": 13, "IN": 14, "IA": 15, "KS": 16,
        "KY": 17, "LA": 18, "ME": 19, "MD": 20, "MA": 21, "MI": 22, "MN": 23, "MS": 24, "MO": 25,
        "MT": 26, "NE": 27, "NV": 28, "NH": 29, "NJ": 30, "NM": 31, "NY": 32, "NC": 33, "ND": 34,
        "OH": 35, "OK": 36, "OR": 37, "PA": 38, "RI": 39, "SC": 40, "SD": 41, "TN": 42, "TX": 43,
        "UT": 44, "VT": 45, "VA": 46, "WA": 47, "WV": 48, "WI": 49, "WY": 50
      };

      //bars
      stateObjs.forEach((d, i) => {
        barChartArea.append('line')
          .attr("x1", stateScale(d['stateAbbrev']))
          .attr("x2", stateScale(d['stateAbbrev']))
          .attr("y1", barChartHeight)
          .attr("y2", fundingScale(d['amntAllocated']))
          .style("stroke", "darkblue")
          .style("stroke-width", 10);
      });
    }
    requestData();
  </script>
</body>