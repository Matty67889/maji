<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>INFO 3300 Project 2</title>

  <!-- Import D3 -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Import Topojson -->
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <style>
    .state {
      fill: lightgrey;
    }

    .outline {
      fill: none;
      stroke: black;
      stroke-width: 1px;
    }

    .graticule {
      fill: none;
      stroke: grey;
      stroke-width: 1px;
    }
  </style>
</head>

<body>
  <h1>Project 2</h1>
  <h3>Map</h3>
  <svg id="disaster-svg" height="600" width="900" style="background: #445; margin-top:50px"></svg>
  <script>

    // d3.csv('data/us_disaster_declarations_clean.csv').then(data => {
    //   console.log(data);
    const svg = d3.select("#disaster-svg");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = { top: 20, right: 20, bottom: 20, left: 20 };
    const mapWidth = width - margin.left - margin.right;
    const mapHeight = height - margin.top - margin.bottom;
    const map = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    //aysnc func to load data and build map
    const requestData = async function () {
      //draw map
      // source: professor Rz
      const us = await d3.json("data/us-smaller.json");
      console.log(us);

      let states = topojson.feature(us, us.objects.states);
      let statesMesh = topojson.mesh(us, us.objects.states);
      let projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
      let path = d3.geoPath().projection(projection);
      console.log(states);
      console.log(statesMesh);

      let graticule = d3.geoGraticule10();
      console.log(graticule);
      map.append("path").attr("class", "graticule").attr("d", path(graticule));

      // Draw states
      let statePaths = map.selectAll("path.state").data(states.features)
        .join("path")
        .attr("class", "state")
        .attr("note", d => d.id)
        .attr("d", path)

      map.append("path").datum(statesMesh)
        .attr("class", "outline")
        .attr("d", path);

      const fema = await d3.csv("data/FEMA_Aid_Distribution_Data_clean.csv");
      console.log(fema);
















      const disasterData = await d3.csv("data/us_disaster_declarations_clean.csv", d3.autoType);
      console.log("disaster data:\n", disasterData);

      // data cleaning

      let stateAbbrevs = ["AL", "AK", "AZ", "AR", "CA", "CO", "CT",
        "DE", "FL", "GA", "HI", "ID", "IL", "IN", "IA", "KS",
        "KY", "LA", "ME", "MD", "MA", "MI", "MN", "MS", "MO",
        "MT", "NE", "NV", "NH", "NJ", "NM", "NY", "NC", "ND",
        "OH", "OK", "OR", "PA", "RI", "SC", "SD", "TN", "TX",
        "UT", "VT", "VA", "WA", "WV", "WI", "WY"];
      // filter out data that is not states
      let filteredFema = fema.filter(d => stateAbbrevs.includes(d['State']));
      console.log(filteredFema);

      // data aggregation

      // get states from filtered data again to avoid
      // reference errors (fema dataset may not contain all states)
      let uniqStates = [];
      filteredFema.forEach(d => {
        // cast money values to ints (they have dollar signs in front of them)
        d['Announced/Allocated'] = Number(d['Announced/Allocated'].replace(/\$/g, ''));
        if (!uniqStates.includes(d['State'])) {
          uniqStates.push(d['State']);
        }
      });
      console.log("states", uniqStates);

      // create dictionary mapping each state to an object
      // that contains the amount allocated, amount of disasters,
      // unique disasters
      let stateDict = {}
      filteredFema.forEach(d => {
        let currState = d['State'];
        let amntAllocated = d['Announced/Allocated'];

        if (currState in stateDict) {
          stateDict[currState]['amntAllocated'] += amntAllocated;
        } else {
          stateDict[currState] = {
            'amntAllocated': amntAllocated,
            'numDisasters': 0,
            'uniqueDisasters': []
          };
        }
      });

      disasterData.forEach(d => {
        let currState = d['state'];
        let disasterName = d['incident_type'];

        if (currState in stateDict) {
          stateDict[currState]['numDisasters'] += 1;
          if (!stateDict[currState]['uniqueDisasters'].includes(disasterName)) {
            stateDict[currState]['uniqueDisasters'].push(disasterName);
          }
        }
      });

      console.log(stateDict);











      // var stateDict = {};   // stateID ===> stateData
    }
    requestData();
  </script>
</body>